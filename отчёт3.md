## Лабораторная работа 3. Представление данных в Python.
# Задание 1. Построение диаграммы рассеяния. Вариант 6. 
# ЦЕЛЬ: 
Построить диаграмму рассеяния на основе выбранных данных.
# ЗАДАЧА: 
Заданы некоторые табличные данные. В них надо выбрать два столбца (фактора), на их основе построить диаграмму рассеяния, причём маркеры должны иметь различные цвета в зависимости от принадлежности к определённому классу.
# ХОД РАБОТЫ. 
Разберём мой код:
1. Импорты библиотек. Код использует следующие библиотеки:

pandas — обработка табличных данных;

seaborn — создание графиков с расширенными возможностями;

matplotlib.pyplot — управление размерами и отображением графиков;

statsmodels.datasets.cancer — встроенный набор данных, содержащий информацию о раке.

2. Установка темы визуализации.

sns.set_theme(style="darkgrid"): устанавливает стиль darkgrid, который делает графики более читаемыми.

3. Определение класса ScatterPlotFromStatsmodels.
Этот класс загружает данные и строит графики.

ИНИЦИАЛИЗАЦИЯ (__init__)

self.df = cancer.load_pandas().data: при создании объекта класса загружается DataFrame с данными о раке.

МЕТОД classify_column. Этот метод разбивает значения числового столбца на категории:

pd.cut(self.df[column], bins=bins, labels=labels)

column — название столбца, который нужно классифицировать;

bins — количество групп;

labels — метки для групп (если не заданы, создаются автоматически).

Пример: если столбец population содержит числовые значения, он будет разделён на 3 группы ["Малые", "Средние", "Большие"].

МЕТОД plot. Этот метод строит диаграмму рассеяния.

sns.scatterplot(data=self.df, x=x_col, y=y_col, hue="class", style="class", palette="deep")

x_col и y_col — столбцы, используемые для осей;

hue="class" — точки раскрашиваются в зависимости от класса;

style="class" — разные классы имеют разные маркеры;

palette="deep" — используется глубокая цветовая палитра.

4. Использование класса

plotter = ScatterPlotFromStatsmodels(): создаётся экземпляр класса

print(plotter.df.columns): выводится список столбцов в загруженном DataFrame, чтобы убедиться, что population и cancer присутствуют.

plotter.classify_column("population", bins=3, labels=["Малые", "Средние", "Большие"]): столбец population разделяется на 3 категории.

plotter.plot("cancer", "population", title="Cancer vs Population"): cтроится диаграмма рассеяния, где:

Ось X — количество случаев рака;

Ось Y — численность населения;

Цвет и стиль точек — классы населения.
# ВЫВОД: 
Данный код успешно загружает данные о заболеваемости раком, классифицирует численность населения на три группы и визуализирует их взаимосвязь с помощью диаграммы рассеяния. Это позволяет наглядно анализировать зависимости между показателями и выявлять возможные закономерности.

# Задание 2. Построение графика динамики временных рядов. Вариант 1.
# ЦЕЛЬ: 
Построить график динамики временных рядов на основе выбранных данных.
# ЗАДАЧА: 
Задано несколько временных рядов в виде таблицы, в которой одно либо два поля указывают на определённый момент времени. Нужно построить графики динамики (единый для всех либо отдельные) для заданных временных рядов за определённый промежуток времени.
# ХОД РАБОТЫ. 
1. Построение диаграммы рассеяния.

Загружаю датасет cancer с помощью statsmodels.datasets.

Выбрала два признака: cancer (число случаев рака) и population (численность населения).

Провела классификацию столбца population на 3 группы (малые, средние, большие) с помощью функции pd.cut.

Визуализировала данные на диаграмме рассеяния с использованием Seaborn:

по оси X — cancer,

по оси Y — population,

цвет и форма точек определялись принадлежностью к определённому классу (class).

Настроила заголовок графика и размер фигуры для лучшего восприятия.

2. Построение графика временного ряда.

Загружаю датасет co2, содержащий ежемесячные значения концентрации углекислого газа в атмосфере.

Преобразовала колонку с датой в формат datetime, убрала пропуски.

Отфильтровала данные по датам: с 1 января 1958 года по 31 декабря 1980 года.

Построила линейный график зависимости уровня CO₂ от времени.

Настроила:

-заголовок,

-оси X и Y с подписями,

-отображение сетки,

-поворот подписей по оси X для лучшей читаемости.
# ВЫВОД: 
Этот код успешно загружает временные данные из встроенного набора CO2 (из statsmodels), преобразует их в удобный формат, фильтрует по заданному диапазону (1958–1980) и строит график изменений уровня CO2.График позволяет визуально анализировать тенденции концентрации углекислого газа, что полезно для климатических исследований и изучения долгосрочных изменений в атмосфере.
